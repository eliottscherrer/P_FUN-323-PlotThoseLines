@using Microsoft.AspNetCore.WebUtilities;
@using Microsoft.AspNetCore.Components.Forms;
@inject HttpClient Http
@inject LocalAssetService LocalAssetService
@page "/"

<div @onclick="CloseDropdown">
<h1>Charts</h1>

<div class="form-group row mb-3">
    <div class="col-md-12 d-flex align-items-center gap-2">
        @if (selectedAssets != null && selectedAssets.Any())
        {
            @foreach (var asset in selectedAssets)
            {
                <div class="asset-chip">
                    @if (!string.IsNullOrEmpty(asset.Logo))
                    {
                        <img src="@asset.Logo" alt="@asset.Symbol" class="asset-chip-logo" />
                    }
                    <span class="asset-chip-text">@asset.Symbol?.ToUpper()</span>
                    <button class="asset-chip-remove" @onclick="() => RemoveAsset(asset.Id)" title="Remove asset">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-x-icon lucide-x"><path d="M18 6 6 18" /><path d="m6 6 12 12" /></svg>
                    </button>
                </div>
            }
        }

        @if (GetAvailableAssets().Count > 0)
        {
            <div class="dropdown-container" @onclick:stopPropagation="true">
                <button class="add-asset-btn" @onclick="ToggleDropdown">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-plus-icon lucide-plus"><path d="M5 12h14" /><path d="M12 5v14" /></svg>
                    <span>Add asset</span>
                </button>
                
                @if (isDropdownOpen && savedAssets != null)
                {
                    <div class="asset-dropdown">
                        @if (!savedAssets.Any())
                        {
                            <div class="dropdown-empty">No assets available</div>
                        }
                        else if (GetAvailableAssets().Count > 0)
                        {
                            @foreach (var asset in GetAvailableAssets())
                            {
                                <div class="dropdown-item" @onclick="() => AddAsset(asset)">
                                    @if (!string.IsNullOrEmpty(asset.Logo))
                                    {
                                        <img src="@asset.Logo" alt="@asset.Symbol" class="dropdown-item-logo" />
                                    }
                                    <span class="dropdown-item-name">@asset.Name</span>
                                    <span class="dropdown-item-symbol">@asset.Symbol?.ToUpper()</span>
                                </div>
                            }
                        }
                    </div>
                }
            </div>
        }
    </div>
</div>

<div class="form-group row mb-3">
    <div class="col-md-12 d-flex align-items-end">
        <div class="time-range-wrapper">
            <div class="segmented" role="tablist" aria-label="Time range">
                <button type="button"
                    class='@GetSegmentClass("1d")'
                    role="tab"
                    aria-selected='@IsSelected("1d")'
                    @onclick='() => SelectedRange = "1d"'>1d</button>

                <button type="button"
                    class='@GetSegmentClass("7d")'
                    role="tab"
                    aria-selected='@IsSelected("7d")'
                    @onclick='() => SelectedRange = "7d"'>7d</button>

                <button type="button"
                    class='@GetSegmentClass("1m")'
                    role="tab"
                    aria-selected='@IsSelected("1m")'
                    @onclick='() => SelectedRange = "1m"'>1m</button>

                <button type="button"
                    class='@GetSegmentClass("1y")'
                    role="tab"
                    aria-selected='@IsSelected("1y")'
                    @onclick='() => SelectedRange = "1y"'>1y</button>

                <button type="button"
                    class='@GetSegmentClass("all")'
                    role="tab"
                    aria-selected='@IsSelected("all")'
                    @onclick='() => SelectedRange = "all"'>All</button>
            </div>
        </div>
    </div>
</div>
<div class="row mb-3">
    <div class="col-md-12 d-flex justify-content-center">
        <button class="btn btn-primary" @onclick="FetchData">
            @if (isLoading)
            {
                <span class="spinner-border spinner-border-sm me-2" role="status">
                    <span class="visually-hidden">Loading...</span>
                </span>
                <span>Loading...</span>
            }
            else
            {
                <span>Fetch Data</span>
            }
        </button>
    </div>
</div>

@if (allAssetData.Any(d => d.Value?.market_chart != null && d.Value.market_chart.Any()))
{
    var validAssets = allAssetData.Where(d => d.Value?.market_chart != null && d.Value.market_chart.Any()).ToList();
    var isSingleAsset = validAssets.Count == 1;
    
    <ApexChart TItem="EnhancedMarketChart" Options="GetChartOptions(isSingleAsset)" @ref="chartRef">
        @* Switch to line charts whenever we have multiple assets on the chart to avoid overlap of colors and imporve clarity *@
        @if (isSingleAsset)
        {
            var assetData = validAssets.First();
            var asset = selectedAssets.FirstOrDefault(a => a.Id == assetData.Key);
            var seriesName = asset?.Symbol?.ToUpper() ?? assetData.Key;
            
            <ApexCandleSeries TItem="EnhancedMarketChart"
                Name="@seriesName"
                Items="GetEnhancedChartData(assetData.Value)"
                XValue="@(p => p.DateTime)"
                Open="@(p => (decimal)p.Open)"
                High="@(p => (decimal)p.High)"
                Low="@(p => (decimal)p.Low)"
                Close="@(p => (decimal)p.Close)" />
        }
        else
        {
            @foreach (var assetData in validAssets)
            {
                var asset = selectedAssets.FirstOrDefault(a => a.Id == assetData.Key);
                var seriesName = asset?.Symbol?.ToUpper() ?? assetData.Key;
                
                <ApexPointSeries TItem="EnhancedMarketChart"
                    Name="@seriesName"
                    Items="GetEnhancedChartData(assetData.Value)"
                    SeriesType="SeriesType.Line"
                    XValue="@(p => p.DateTime)"
                    YValue="@(p => (decimal)p.Price)" />
            }
        }
    </ApexChart>
}
else if (allAssetData.Any())
{
    <div class="alert alert-info">
        <strong>No chart data available.</strong> The dataset is empty.
    </div>
}

@if (isLoading)
{
    <div class="d-flex justify-content-center mt-5">
        <div class="spinner-border text-primary" role="status">
            <span class="visually-hidden">Loading...</span>
        </div>
    </div>
}

@if (errorMessage != null)
{
    <div class="alert alert-danger mt-3">
        <strong>Error:</strong> @errorMessage
    </div>
}

@code {
    private string interval = "day";
    private int dataLength = 30;
    private string vsCurrency = "usd";
    private Dictionary<string, CoinHistoryDataResponse?> allAssetData = new();
    private bool isLoading = false;
    private string? errorMessage;
    private List<LocalAsset>? savedAssets;
    private List<LocalAsset> selectedAssets = new();
    private string selectedAssetId = "";
    private ApexChart<EnhancedMarketChart>? chartRef;
    private bool isDropdownOpen = false;
    private string selectedRange = "1m";
    private string SelectedRange
    {
        get => selectedRange;
        set
        {
            if (selectedRange == value) return;
            selectedRange = value;
            ApplyPresetRange(value);
            StateHasChanged();
        }
    }

    private ApexChartOptions<EnhancedMarketChart> GetChartOptions(bool isSingleAsset)
    {
        return new ApexChartOptions<EnhancedMarketChart>
        {
            Chart = new Chart
            {
                Type = isSingleAsset ? ChartType.Candlestick : ChartType.Line, // Switch to line charts whenever we have multiple assets on the chart to avoid overlap of colors and imporve clarity
                Zoom = new Zoom { Enabled = true },
                Toolbar = new Toolbar { Show = true },
                ForeColor = "#334155"
            },
        Xaxis = new XAxis
        {
            Type = XAxisType.Datetime,
            Title = new AxisTitle { Text = "Date/Time" },
            Labels = new XAxisLabels
            {
                DatetimeUTC = false,
                DatetimeFormatter = new DatetimeFormatter
                {
                    Year = "yyyy",
                    Month = "dd MMM",
                    Day = "dd MMM",
                    Hour = "HH:mm"
                }
            },
            TickAmount = 6
        },
        Yaxis = new List<YAxis>
        {
            new YAxis
            {
                Title = new AxisTitle { Text = "Price (USD)" },
                Labels = new YAxisLabels()
            }
        },
        Stroke = new Stroke { Curve = Curve.Smooth, Width = 3 },
        DataLabels = new DataLabels { Enabled = false },
        Markers = new Markers { Size = 0 },
        Grid = new Grid
        {
            BorderColor = "#f1f1f1",
            StrokeDashArray = 4,
            Column = new GridColumn
            {
                Colors = new List<string> { "#f8f8f8", "transparent" },
                Opacity = 0.75
            }
        },
        PlotOptions = new PlotOptions
        {
            Candlestick = new PlotOptionsCandlestick
            {
                Colors = new PlotOptionsCandlestickColors
                {
                    Upward = "#d71515",
                    Downward = "#5a9f68"
                }
            }
        },
        // Random colors otherwise all the lines are blue and it's bad for clarity
        Colors = new List<string> { "#2E93FA", "#A3E635", "#F59E0B", "#EF4444", "#8B5CF6", "#EC4899", "#14B8A6", "#F97316" },
        Legend = new Legend { Show = true, Position = LegendPosition.Top },
        Tooltip = new Tooltip { Shared = true, Intersect = false, X = new TooltipX { Format = "dd MMM yyyy HH:mm" } }
        };
    }

    private List<EnhancedMarketChart> GetEnhancedChartData(CoinHistoryDataResponse? data)
    {
        if (data?.market_chart == null || !data.market_chart.Any())
            return new List<EnhancedMarketChart>();

        var rng = new Random();
        var points = data.market_chart.ToArray();
        var result = new List<EnhancedMarketChart>(points.Length);
        double previousClose = points.First().price;

        // Consts
        const double anchorWeight = 0.7; // Make the "Close" stay not too different from the base price
        const double maxJumpPct = 0.25;
        const double noisePct = 0.003;
        const double minWickPct = 0.002;
        const double maxWickPct = 0.06;

        result = points.Select(entry =>
        {
            var basePrice = entry.price;
            double open = previousClose;

            double blended = anchorWeight * basePrice + (1 - anchorWeight) * open;
            double noise = (rng.NextDouble() - 0.5) * 2 * noisePct * blended;
            double closeUnclamped = blended + noise;

            double minClose = open * (1 - maxJumpPct);
            double maxClose = open * (1 + maxJumpPct);
            double close = Math.Clamp(closeUnclamped, minClose, maxClose);

            double bodyPct = Math.Abs(close - open) / open;
            double wickPct = bodyPct * 0.6 + 0.003 + (rng.NextDouble() - 0.5) * 0.003;
            wickPct = Math.Clamp(wickPct, minWickPct, maxWickPct);

            double high = Math.Max(open, close) * (1.0 + wickPct);
            double low = Math.Min(open, close) * (1.0 - wickPct);

            previousClose = close;

            return new EnhancedMarketChart
            {
                DateTime = entry.timestamp.ToLocalDateTimeFromUnixMs(),
                Price = basePrice,
                Open = Math.Round(open, 2),
                Close = Math.Round(close, 2),
                Low = Math.Round(low, 2),
                High = Math.Round(high, 2),
                MarketCap = entry.market_cap,
                Volume = entry.vol_spot_24h
            };
        }).ToList();

        return result;
    }

    protected override void OnInitialized()
    {
        LoadSavedAssets();
        ApplyPresetRange(selectedRange);
    }

    // From: https://tokeninsight-api.readme.io/reference/get_history-coins-id
    // This para decides how many data points you will get in the response, and different lengths are supported for different intervals.
    // For day, any number between 1 - 365, -1 stands for the max length, and 90 is the default if left blank.
    // For hour, any number between 1 - 8784, 24 in the default if left blank.
    // For minute, any number between 1 - 10080, 60 is the default if left blank.
    private void ApplyPresetRange(string range)
    {
        switch (range)
        {
            case "1d":
                interval = "hour";
                dataLength = 24;
                break;
            case "7d":
                interval = "day";
                dataLength = 7;
                break;
            case "1m":
                interval = "day";
                dataLength = 30;
                break;
            case "1y":
                interval = "day";
                dataLength = 365;
                break;
            case "all":
                interval = "day";
                dataLength = -1;
                break;
            default:
                interval = "day";
                dataLength = 365;
                break;
        }
    }

    private bool IsSelected(string range) => SelectedRange == range;
    private string GetSegmentClass(string range) => IsSelected(range) ? "segment selected" : "segment";

    private void LoadSavedAssets()
    {
        try
        {
            savedAssets = LocalAssetService.GetAssets();
        }
        catch (Exception ex)
        {
            System.Diagnostics.Debug.WriteLine($"Error loading saved assets: {ex.Message}");
        }
    }

    private void OnAssetSelected(ChangeEventArgs e)
    {
        selectedAssetId = e.Value?.ToString() ?? "";
    }

    private void ToggleDropdown()
    {
        isDropdownOpen = !isDropdownOpen;
    }

    private List<LocalAsset> GetAvailableAssets()
    {
        if (savedAssets == null) return new List<LocalAsset>();
        
        // Return only assets that are not already selected
        return savedAssets.Where(a => !selectedAssets.Any(s => s.Id == a.Id)).ToList();
    }

    private void AddAsset(LocalAsset asset)
    {
        if (!selectedAssets.Any(a => a.Id == asset.Id))
        {
            selectedAssets.Add(asset);
            isDropdownOpen = false;
            StateHasChanged();
        }
    }

    private void RemoveAsset(string? assetId)
    {
        var assetToRemove = selectedAssets.FirstOrDefault(a => a.Id == assetId);
        if (assetToRemove != null)
        {
            selectedAssets.Remove(assetToRemove);
            StateHasChanged();
        }
    }

    private async Task FetchData()
    {
        // Require at least one selected asset
        if (!selectedAssets.Any())
        {
            errorMessage = "Please add at least one asset to the chart";
            return;
        }

        isLoading = true;
        errorMessage = null;
        allAssetData.Clear();

        try
        {
            // Fetch data for all selected assets
            var fetchTasks = selectedAssets.Select(async asset =>
            {
                if (string.IsNullOrWhiteSpace(asset.Id))
                    return (asset.Id, (CoinHistoryDataResponse?)null);

                try
                {
                    var queryParams = new Dictionary<string, string?>
                    {
                        { "interval", interval },
                        { "length", dataLength.ToString() },
                        { "vs_currency", vsCurrency }
                    };
                    var url = QueryHelpers.AddQueryString($"history/coins/{asset.Id}", queryParams);
                    var response = await Http.GetFromJsonAsync<ApiResponse>(url);

                    if (response?.status?.code == 0 && response?.data != null)
                    {
                        return (asset.Id!, response.data);
                    }
                    
                    return (asset.Id!, (CoinHistoryDataResponse?)null);
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Error fetching data for {asset.Symbol}: {ex.Message}");
                    return (asset.Id!, (CoinHistoryDataResponse?)null);
                }
            });

            var results = await Task.WhenAll(fetchTasks);
            
            // Store all results
            foreach (var (assetId, data) in results)
            {
                if (!string.IsNullOrEmpty(assetId))
                {
                    allAssetData[assetId] = data;
                }
            }

            // Check if any data was fetched successfully
            if (!allAssetData.Any(d => d.Value?.market_chart != null && d.Value.market_chart.Any()))
            {
                errorMessage = "No data could be fetched for any of the selected assets.";
            }
            else if (chartRef is not null)
            {
                await chartRef.UpdateOptionsAsync(true, true, false, null);
            }
        }
        catch (Exception ex)
        {
            errorMessage = $"Error: {ex.Message}";
            Console.WriteLine($"API Request Error: {ex}");

            if (ex.Message.Contains("JSON") || ex.Message.Contains("convert"))
            {
                errorMessage += " (Data format issue - check the console for more details)";
            }
        }
        finally
        {
            isLoading = false;
        }
    }

    public class ApiResponse
    {
        public CoinHistoryDataResponse? data { get; set; }
        public Status? status { get; set; }
    }

    public class CoinHistoryDataResponse
    {
        public string? id { get; set; }
        public string? logo { get; set; }
        public MarketChart[]? market_chart { get; set; }
        public string? name { get; set; }
        public string? symbol { get; set; }
        public string? vs_currency { get; set; }

        public PageInfo? page_info { get; set; }
    }

    public class MarketChart
    {
        public double market_cap { get; set; }
        public double price { get; set; }
        public long timestamp { get; set; }
        public double vol_spot_24h { get; set; }
    }

    public class EnhancedMarketChart
    {
        public DateTime DateTime { get; set; }
        public double Price { get; set; }
        public double Open { get; set; }
        public double Close { get; set; }
        public double Low { get; set; }
        public double High { get; set; }
        public double MarketCap { get; set; }
        public double Volume { get; set; }
    }

    public class PageInfo
    {
        public int total_results { get; set; }
    }

    public class Status
    {
        public int code { get; set; }
        public string? message { get; set; }
        public long timestamp { get; set; }
    }

    private void CloseDropdown()
    {
        if (isDropdownOpen)
        {
            isDropdownOpen = false;
            StateHasChanged();
        }
    }
}
</div>